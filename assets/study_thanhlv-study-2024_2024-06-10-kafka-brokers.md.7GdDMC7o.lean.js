import{_ as n,j as a,o as e,v as i,m as t,q as l}from"./chunks/framework.OuVixYWh.js";const c=JSON.parse('{"title":"Kafka Brokers là gì ?","description":"","frontmatter":{"footer":true,"title":"Kafka Brokers là gì ?","authors":["lethanh"],"date":"2024-06-10T00:00:00.000Z","outline":"deep","image":"https://static-cdn.thanhlv.com/study/thanhlv-study-2024/2024-06-10-kafka-brokers/Leaders-and-followers.png","draft":false,"group":"2.1 Kafka"},"headers":[{"level":2,"title":"Kafka Brokers là gì ?","slug":"kafka-brokers-la-gi","link":"#kafka-brokers-la-gi","children":[]},{"level":2,"title":"Vai trò của Kafka Brokers với Produce khi Produce gửi record đến Brokers","slug":"vai-tro-cua-kafka-brokers-voi-produce-khi-produce-gui-record-đen-brokers","link":"#vai-tro-cua-kafka-brokers-voi-produce-khi-produce-gui-record-đen-brokers","children":[]},{"level":2,"title":"Vai trò của Kafka Brokers với Consumer khi Consumer nhận record từ Brokers","slug":"vai-tro-cua-kafka-brokers-voi-consumer-khi-consumer-nhan-record-tu-brokers","link":"#vai-tro-cua-kafka-brokers-voi-consumer-khi-consumer-nhan-record-tu-brokers","children":[]},{"level":2,"title":"Topics và partitions","slug":"topics-va-partitions","link":"#topics-va-partitions","children":[{"level":3,"title":"Topics","slug":"topics","link":"#topics","children":[]},{"level":3,"title":"partitions","slug":"partitions","link":"#partitions","children":[{"level":4,"title":"Cách Kafka Broker map record đến partition.","slug":"cach-kafka-broker-map-record-đen-partition","link":"#cach-kafka-broker-map-record-đen-partition","children":[]}]},{"level":3,"title":"Offsets","slug":"offsets","link":"#offsets","children":[]},{"level":3,"title":"Xác định số lượng partition sử dụng","slug":"xac-đinh-so-luong-partition-su-dung","link":"#xac-đinh-so-luong-partition-su-dung","children":[]},{"level":3,"title":"Tạo một topic","slug":"tao-mot-topic","link":"#tao-mot-topic","children":[]},{"level":3,"title":"Segments","slug":"segments","link":"#segments","children":[{"level":4,"title":"Ví dụ về segments của một partition index.","slug":"vi-du-ve-segments-cua-mot-partition-index","link":"#vi-du-ve-segments-cua-mot-partition-index","children":[{"level":6,"title":"Các file Segment","slug":"cac-file-segment","link":"#cac-file-segment","children":[]},{"level":6,"title":"File leader-epoch-checkpoint","slug":"file-leader-epoch-checkpoint","link":"#file-leader-epoch-checkpoint","children":[]},{"level":6,"title":"File partition.metadata","slug":"file-partition-metadata","link":"#file-partition-metadata","children":[]},{"level":5,"title":"Segments position index","slug":"segments-position-index","link":"#segments-position-index","children":[]}]}]},{"level":3,"title":"Cấu hình cleanup.policy","slug":"cau-hinh-cleanup-policy","link":"#cau-hinh-cleanup-policy","children":[{"level":4,"title":"Các giá trị của cleanup.policy","slug":"cac-gia-tri-cua-cleanup-policy","link":"#cac-gia-tri-cua-cleanup-policy","children":[]},{"level":4,"title":"2 cách thức quản lý Record cleanup.policy=delete","slug":"_2-cach-thuc-quan-ly-record-cleanup-policy-delete","link":"#_2-cach-thuc-quan-ly-record-cleanup-policy-delete","children":[{"level":5,"title":"Retention Time-Based Policy (Chính sách dựa trên thời gian lưu trữ)","slug":"retention-time-based-policy-chinh-sach-dua-tren-thoi-gian-luu-tru","link":"#retention-time-based-policy-chinh-sach-dua-tren-thoi-gian-luu-tru","children":[]},{"level":5,"title":"Retention Size-Based Policy (Chính sách dựa trên kích thước dữ liệu)","slug":"retention-size-based-policy-chinh-sach-dua-tren-kich-thuoc-du-lieu","link":"#retention-size-based-policy-chinh-sach-dua-tren-kich-thuoc-du-lieu","children":[]},{"level":5,"title":"Kết hợp cả Time-Based Policy và Size-Based Policy","slug":"ket-hop-ca-time-based-policy-va-size-based-policy","link":"#ket-hop-ca-time-based-policy-va-size-based-policy","children":[]},{"level":5,"title":"Lưu trữ dữ liệu mãi mãi.","slug":"luu-tru-du-lieu-mai-mai","link":"#luu-tru-du-lieu-mai-mai","children":[]}]}]}]},{"level":2,"title":"Tiered storage","slug":"tiered-storage","link":"#tiered-storage","children":[]},{"level":2,"title":"Cluster Metadata","slug":"cluster-metadata","link":"#cluster-metadata","children":[]},{"level":2,"title":"Leaders and followers","slug":"leaders-and-followers","link":"#leaders-and-followers","children":[]},{"level":2,"title":"Replication","slug":"replication","link":"#replication","children":[{"level":3,"title":"Mức độ replication","slug":"muc-đo-replication","link":"#muc-đo-replication","children":[]},{"level":3,"title":"Phân bổ","slug":"phan-bo","link":"#phan-bo","children":[]}]},{"level":2,"title":"acknowledgments","slug":"acknowledgments","link":"#acknowledgments","children":[]},{"level":2,"title":"Một số lưu ý về Kafka Brokers","slug":"mot-so-luu-y-ve-kafka-brokers","link":"#mot-so-luu-y-ve-kafka-brokers","children":[]},{"level":2,"title":"Summary","slug":"summary","link":"#summary","children":[]}],"relativePath":"study/thanhlv-study-2024/2024-06-10-kafka-brokers.md","filePath":"study/thanhlv-study-2024/2024-06-10-kafka-brokers.md","lastUpdated":1748772803000}'),s={name:"study/thanhlv-study-2024/2024-06-10-kafka-brokers.md"},o=[i("",107),t("details",{class:"details custom-block"},[t("summary",null,"Câu hỏi và trả lời"),t("ul",null,[t("li",null,[t("strong",null,"Kafka Broker là gì?"),t("ul",null,[t("li",null,"Kafka Broker là một Kafka server đóng vai trò lưu trữ dữ liệu (storage layer) trong kiến trúc Kafka."),t("li",null,"Nó có thể chạy thành một cluster và mở rộng ra nhiều data centers. Kafka Brokers chịu trách nhiệm quản lý dữ liệu (lưu trữ, đọc, replication), quản lý topic và partition, và xử lý các request từ client.")])]),t("li",null,[t("strong",null,"Vai trò của Kafka Brokers đối với Producers và Consumers là gì?"),t("ul",null,[t("li",null,"Với Producers: Kafka Brokers nhận các records từ Producers để lưu trữ."),t("li",null,"Với Consumers: Kafka Brokers cung cấp các records từ topic mà Consumers yêu cầu. Việc sử dụng Record sẽ không làm ảnh hưởng đến việc lưu dữ liệu hoặc việc sử dụng Record bởi các Consumer khác.")])]),t("li",null,[t("strong",null,"Topic trong Kafka là gì?"),t("ul",null,[t("li",null,"Topic về mặt kiến trúc là tên của folder chứa các file Kafka, nơi các Record được thêm vào cuối file. Kafka Brokers nhận key-value message dưới dạng raw byte, lưu trữ và phục vụ các yêu cầu đọc với cùng định dạng."),t("li",null,"Topic về mặt logic là một cách để phân loại các Record, mỗi Record sẽ được gửi đến một topic cụ thể và mỗi topic sẽ được chia thành các partition.")])]),t("li",null,[t("strong",null,"Partition trong Kafka là gì?"),t("ul",null,[t("li",{partition:"",number:""},"Các topic được chia nhỏ thành các partition, mỗi partition là một số nguyên bắt đầu từ 0. Kafka brokers gắn số partition vào đuôi của folder topic với định dạng {Topic name}-"),t("li",null,"Các Record được Producer gửi đến sẽ được lưu vào partition, mỗi partition sẽ có một leader và một số follower."),t("li",null,"Partition giúp Kafka mở rộng dữ liệu trên nhiều broker và cung cấp khả năng chịu lỗi."),t("li",null,"Mỗi partition sẽ được chia thành các segment để quản lý dữ liệu.")])]),t("li",null,[t("strong",null,"Offset trong Kafka là gì?"),t("ul",null,[t("li",null,"Khi broker thêm một Record, nó sẽ thêm một ID được gọi là offset. Offset bắt đầu từ 0 và tăng lên 1 mỗi khi thêm một Record. Consumer sử dụng offset để xác định vị trí của Record đã sử dụng và sử dụng để tìm kiếm Record bởi offset.")])]),t("li",null,[t("strong",null,"Kafka lưu trữ dữ liệu như thế nào?"),t("ul",null,[t("li",null,"Kafka sử dụng file system để lưu trữ dữ liệu bằng cách nối thêm các Record vào cuối file trong một topic. Kafka Brokers nhận key-value message dưới dạng raw byte, lưu trữ và phục vụ các yêu cầu đọc với cùng định dạng (raw data).")])]),t("li",null,[t("strong",null,"Segment trong Kafka là gì?"),t("ul",null,[t("li",null,"Broker sẽ chia partition thành các tệp nhỏ hơn gọi là segments. Việc sử dụng Segments giúp thực hiện push Record mới và truy xuất Record bằng offset dễ dàng hơn. Kafka Broker mặc định để mỗi segment là 1GB hoặc có thể chỉ định ở segment.bytes.")])]),t("li",null,[t("strong",null,"cleanup.policy trong Kafka là gì và có những giá trị nào?"),t("ul",null,[t("li",null,[l("cleanup.policy là cấu hình cách thức Kafka quản lý và dọn dẹp các Record cũ của topic sau khi đã được ghi vào. "),t("ul",null,[t("li",null,[l("Các giá trị bao gồm: "),t("ul",null,[t("li",null,"delete: Kafka sẽ xóa các Record sau khi chúng vượt qua giới hạn thời gian lưu trữ hoặc dung lượng lưu trữ."),t("li",null,"compact: Kafka sẽ nén các Record, chỉ giữ lại Record có giá trị mới nhất cho mỗi key."),t("li",null,"compact,delete: Kết hợp cả hai chính sách trên.")])])])])])]),t("li",null,[t("strong",null,"Các mức độ acknowledgments (acks) trong Kafka là gì?"),t("ul",null,[t("li",null,"acks=0: Producer không chờ ACK từ broker."),t("li",null,"acks=1: Producer chờ ACK từ leader."),t("li",null,"acks=all hoặc acks=-1: Producer chờ ACK từ tất cả các follower")])]),t("li",null,[t("strong",null,"Replication trong Kafka là gì và tại sao nó quan trọng?"),t("ul",null,[t("li",null,"Replication là cơ chế sao chép dữ liệu từ leader sang follower để đảm bảo tính toàn vẹn và đồng bộ dữ liệu. Khi một Broker Leader không khả dụng, Kafka sẽ chuyển đổi một follower khác trở thành leader.")])]),t("li",null,[t("strong",null,"Tiered storage trong Kafka là gì và lợi ích của nó?"),t("ul",null,[t("li",null,"Tiered storage là một cơ chế cho phép Kafka lưu trữ dữ liệu trên remote storage như Amazon S3, HDFS. Giúp dữ liệu của Kafka có thể lưu trữ lâu dài hơn, giảm chi phí lưu trữ và dung lượng ổ cứng")])]),t("li",null,[t("strong",null,"Dùng Tiered storage có làm tăng độ trễ không ?"),t("ul",null,[t("li",null,"Với Tiered storage, dữ liệu mới nhất và sẽ được lưu trữ ở local tier, giúp Kafka đọc và ghi dữ liệu nhanh chóng. Dữ liệu cũ hơn sẽ được lưu trữ ở remote tier, giúp giảm chi phí lưu trữ và dung lượng ổ cứng."),t("li",null,"Nếu Comsumer cần đọc dữ liệu cũ hơn, Kafka sẽ đọc từ remote tier, điều này có thể làm tăng độ trễ.")])]),t("li",null,[t("strong",null,"Khi nào Kafka chuyển log Segment lên tiered storage?"),t("ul",null,[t("li",null,[l("Kafka sẽ dựa theo cấu hình "),t("code",null,"log.segment.tier.upgrade.delay.ms"),l(" để chờ đẩy dữ liệu lên. Không có dữ liệu default, default Kafka sẽ không đẩy dữ liệu.")]),t("li",null,[l("Khi một segment đóng lại (Đầy hoặc quá thời gian), Kafka sẽ bắt đầu chờ "),t("code",null,"log.segment.tier.upgrade.delay.ms"),l(" trước khi đẩy dữ liệu lên tiered storage.")])])]),t("li",null,[t("strong",null,"Khi nào một log segment được đóng lại?"),t("ul",null,[t("li",null,[l("Khi chạm ngưỡng cấu hình size "),t("code",null,"segment.bytes (Default 1G)"),l(" hoặc hết thời gian của một segment "),t("code",null,"segment.ms (Default 7 ngày)"),l(".")])])]),t("li",null,[t("strong",null,"Kafka sử dụng Zookeeper hoặc Kafka Raft (KR) để làm gì?"),t("ul",null,[t("li",null,"Kafka sử dụng Zookeeper hoặc Kafka Raft để lưu trữ metadata của cluster. Các metadata bao gồm: Cluster Membership, quản lý các topic, partition, offset")])]),t("li",null,[t("strong",null,"Leader và Follower trong Kafka là gì và vai trò của chúng")]),t("li",null,"Mỗi partition sẽ có một broker đóng vai trò là leader và các broker khác sẽ đóng vai trò là follower. Partition leader sẽ xử lý tất cả các yêu cầu ghi và đọc từ client, các follower sẽ sao chép dữ liệu từ leader"),t("li",null,"Khi node Kafka leader không khả dụng, Kafka sẽ chuyển đổi một follower khác trở thành leader.")])],-1),t("h1",{id:"ref",tabindex:"-1"},[l("REF: "),t("a",{class:"header-anchor",href:"#ref","aria-label":'Permalink to "REF:"'},"​")],-1),t("ul",null,[t("li",null,[t("a",{href:"https://ibm-cloud-architecture.github.io/refarch-eda/technology/kafka-overview/",target:"_blank",rel:"noreferrer"},"https://ibm-cloud-architecture.github.io/refarch-eda/technology/kafka-overview/")]),t("li",null,[t("strong",null,"Kafka book"),l(": "),t("a",{href:"https://static-cdn.thanhlv.com/study/thanhlv-study-2024/Kafka%20Event%20Streaming%20Platform%20In%20Action.pdf",target:"_blank",rel:"noreferrer"},"Kafka Event Streaming Platform In Action.pdf")])],-1)];const r=n(s,[["render",function(n,i,t,l,c,s){return e(),a("div",null,o)}]]);export{c as __pageData,r as default};
